package plugin

import (
	"bytes"
	"context"
	"fmt"
	"sync"

	"github.com/smartcontractkit/libocr/offchainreporting2plus/ocr3_1types"
	"github.com/smartcontractkit/smdkg/dkgocr/dkgocrtypes"
	"github.com/smartcontractkit/smdkg/internal/crypto/dkg"
	"github.com/smartcontractkit/smdkg/internal/crypto/dkgtypes"
	"github.com/smartcontractkit/smdkg/internal/crypto/math"
)

// Contains all the in-memory cached state for a DKGPlugin, shouldn't be accessed directly.
// Must be accessed in a thread-safe manner.
type cachedValues struct {
	// The DKG instance used for this plugin, initialized once and never changed.
	dkg dkg.DKG

	// The ocr bandwidth limit estimator for this plugin.
	limitEstimator limitsEstimator

	// Maps each attempt number to serialized blob handle of the initial dealing generated by its own.
	// Each initial dealing can only last for one dkg attempt, must not be reused for different attempts
	initialDealingBlobHandleBytes map[int][]byte

	// Maps each attempt number to a slice of verified initial dealings.
	// For each dealer (by index), this records the first initial dealing that was received and verified.
	// Nil means no verified initial dealing received yet from that dealer for that attempt.
	initialDealings map[int][]*initialDealingCache

	// Maps each attempt number to a slice of verified decryption key shares for inner dealings.
	// For each dealer (by index), this records the first decryption key shares that was received and verified.
	// Nil means no verified decryption key shares received yet from that dealer for that attempt.
	decryptionKeyShares map[int][]*decryptionKeySharesCache

	// Maps each attempt number to the initial dealings committed during that attempt.
	committedInitialDealings map[int]initialDealings

	// Maps each attempt number to the committed banned dealers before that attempt.
	committedBannedDealers map[int]bannedDealers

	// The reports plus precursor generated for this dkg instance once a dkg instance is finished.
	reportsPlusPrecursor ocr3_1types.ReportsPlusPrecursor

	// Mutex to protect concurrent access to the cached values.
	mu sync.Mutex
}

// The tuple for a verified initial dealing to be cached for avoiding redundant verification.
type initialDealingCache struct {
	unverifiedBytes []byte                     // the unverified bytes received on the network
	verified        dkg.VerifiedInitialDealing // the unmarshaled and verified initial dealing
}

// The tuple for verified decryption key shares from a dealer to be cached for avoiding redundant verification.
type decryptionKeySharesCache struct {
	unverifiedBytes []byte                                          // the unverified bytes received on the network
	verified        dkg.VerifiedDecryptionKeySharesForInnerDealings // the unmarshaled and verified decryption key shares
}

// Create a new cachedValues instance, with estimated limits and potentially a DKG instance if this is a fresh dealing,
// or the previous result package is available in db for resharing case.
func newCachedValues(ctx context.Context, db dkgocrtypes.ResultPackageDatabase, iid dkgtypes.InstanceID,
	curve math.Curve, dealers []dkgtypes.P256PublicKey, recipients []dkgtypes.P256PublicKey, f_D int, t_R int,
	keyring dkgtypes.P256Keyring, previousInstanceID *dkgocrtypes.InstanceID, pluginConfigLength int,
) (*cachedValues, error) {
	// Estimate the bandwidth limits for this plugin instance.
	// If this is a resharing, use the looser estimates that do not depend on t_D first.
	// Will try to get a tighter estimate later when t_D (in result package) is available.
	limitsEstimator := NewLimitsEstimator(iid, curve, len(dealers), f_D, len(recipients), t_R, previousInstanceID != nil, nil, pluginConfigLength)

	cachedValues := &cachedValues{
		nil,
		limitsEstimator,
		make(map[int][]byte),
		make(map[int][]*initialDealingCache),
		make(map[int][]*decryptionKeySharesCache),
		make(map[int]initialDealings),
		make(map[int]bannedDealers),
		nil,
		sync.Mutex{},
	}

	// Initialize a DKG instance.
	// If the previous result package is available in db for resharing case, also update the t_D parameter in the limits estimator to get tighter estimates.
	_, err := cachedValues.newDKGAndUpdateLimits(ctx, db, iid, curve, dealers, recipients, f_D, t_R, keyring, previousInstanceID)
	if err != nil {
		return nil, fmt.Errorf("failed to create DKG instance: %w", err)
	}

	return cachedValues, nil
}

// Get the cached DKG instance.
func (c *cachedValues) getDKG() dkg.DKG {
	c.mu.Lock()
	defer c.mu.Unlock()
	return c.dkg
}

// Create a new DKG instance and update the t_D parameter in the limits estimator if applicable.
// This should only be called when the DKG instance is not created yet.
func (c *cachedValues) newDKGAndUpdateLimits(ctx context.Context, db dkgocrtypes.ResultPackageDatabase,
	iid dkgtypes.InstanceID, curve math.Curve, dealers []dkgtypes.P256PublicKey, recipients []dkgtypes.P256PublicKey,
	f_D int, t_R int, keyring dkgtypes.P256Keyring, previousInstanceID *dkgocrtypes.InstanceID,
) (dkg.DKG, error) {
	// Read the previous result package from db first.
	resultPackage, err := readPreviousResultPackage(ctx, db, previousInstanceID)
	if err != nil {
		return nil, fmt.Errorf("failed to read prior result package: %w", err)
	}

	// Create the DKG instance.
	dkgInstance, err := newDKG(iid, curve, dealers, recipients, f_D, t_R, keyring, resultPackage)
	if err != nil {
		return nil, fmt.Errorf("failed to create DKG instance: %w", err)
	}

	c.mu.Lock()
	defer c.mu.Unlock()

	// Set the DKG instance and update t_D in the limits estimator if applicable.
	c.dkg = dkgInstance
	if resultPackage != nil {
		c.limitEstimator.UpdateT_D(resultPackage.Config.T) // Update t_D in the limits estimator to get tighter estimates
	}
	return dkgInstance, nil
}

// Get from cache the serialized blob handle for the initial dealing generated by itself.
func (c *cachedValues) getInitialDealingBlobHandleBytes(attempt int) []byte {
	c.mu.Lock()
	defer c.mu.Unlock()

	if blob, exists := c.initialDealingBlobHandleBytes[attempt]; exists {
		return blob
	}
	return nil
}

// Cache the serialized blob handle for the initial dealing generated by itself.
func (c *cachedValues) putInitialDealingBlobHandleBytes(attempt int, blobHandleBytes []byte) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.initialDealingBlobHandleBytes[attempt] = blobHandleBytes
}

// Get the unmarshaled and verified version of an unverified and marshaled initial dealing (raw) the from cache if exists.
func (c *cachedValues) getVerifiedInitialDealing(attempt int, n_D int, dealer int, raw []byte) dkg.VerifiedInitialDealing {
	c.mu.Lock()
	defer c.mu.Unlock()

	if _, exists := c.initialDealings[attempt]; !exists {
		c.initialDealings[attempt] = make([]*initialDealingCache, n_D)
	}

	initialDealingFound := c.initialDealings[attempt][dealer]
	if initialDealingFound != nil && bytes.Equal(initialDealingFound.unverifiedBytes, raw) {
		return initialDealingFound.verified
	} else {
		return nil
	}
}

// Cache the first verified initial dealing for an attempt from a dealer (by index) to avoid redundant verification.
func (c *cachedValues) putVerifiedInitialDealing(attempt int, n_D int, dealer int, raw []byte, dealing dkg.VerifiedInitialDealing) {
	c.mu.Lock()
	defer c.mu.Unlock()

	if _, exists := c.initialDealings[attempt]; !exists {
		c.initialDealings[attempt] = make([]*initialDealingCache, n_D)
	}

	if c.initialDealings[attempt][dealer] == nil {
		c.initialDealings[attempt][dealer] = &initialDealingCache{raw, dealing}
	}
}

// Get the unmarshaled and verified version of an unverified and marshaled decryption key shares for inner dealing (raw) from the cache if exists.
func (c *cachedValues) getVerifiedDecryptionKeyShares(attempt int, n_D int, dealer int, raw []byte) dkg.VerifiedDecryptionKeySharesForInnerDealings {
	c.mu.Lock()
	defer c.mu.Unlock()

	if _, exists := c.decryptionKeyShares[attempt]; !exists {
		c.decryptionKeyShares[attempt] = make([]*decryptionKeySharesCache, n_D)
	}

	initialDealingFound := c.decryptionKeyShares[attempt][dealer]
	if initialDealingFound != nil && bytes.Equal(initialDealingFound.unverifiedBytes, raw) {
		return initialDealingFound.verified
	} else {
		return nil
	}
}

// Cache the first verified decryption key shares for an attempt from a dealer (by index) to avoid redundant verification.
func (c *cachedValues) putVerifiedDecryptionKeyShares(attempt int, n_D int, dealer int, raw []byte, shares dkg.VerifiedDecryptionKeySharesForInnerDealings) {
	c.mu.Lock()
	defer c.mu.Unlock()

	if _, exists := c.decryptionKeyShares[attempt]; !exists {
		c.decryptionKeyShares[attempt] = make([]*decryptionKeySharesCache, n_D)
	}

	if c.decryptionKeyShares[attempt][dealer] == nil {
		c.decryptionKeyShares[attempt][dealer] = &decryptionKeySharesCache{raw, shares}
	}
}

// Returns the initial dealings committed during that attempt, or nil if not found.
func (c *cachedValues) getCommittedInitialDealings(attempt int) initialDealings {
	c.mu.Lock()
	defer c.mu.Unlock()

	if dealings, exists := c.committedInitialDealings[attempt]; exists {
		return dealings
	}
	return nil
}

// Cache the initial dealings committed during that attempt.
func (c *cachedValues) putCommittedInitialDealings(attempt int, dealings initialDealings) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.committedInitialDealings[attempt] = dealings
}

// Returns the committed banned dealers before that attempt, or nil if not found.
func (c *cachedValues) getCommittedBannedDealers(attempt int) bannedDealers {
	c.mu.Lock()
	defer c.mu.Unlock()

	if banned, exists := c.committedBannedDealers[attempt]; exists {
		return banned
	}
	return nil
}

// Cache the committed banned dealers before that attempt.
func (c *cachedValues) putCommittedBannedDealers(attempt int, banned bannedDealers) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.committedBannedDealers[attempt] = banned
}

// Get the reports plus precursor generated when the DKG instance is finished.
func (c *cachedValues) getReportsPlusPrecursor() ocr3_1types.ReportsPlusPrecursor {
	c.mu.Lock()
	defer c.mu.Unlock()
	return c.reportsPlusPrecursor
}

// Cache the reports plus precursor generated when the DKG instance is finished.
func (c *cachedValues) putReportsPlusPrecursor(reportsPlusPrecursor ocr3_1types.ReportsPlusPrecursor) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.reportsPlusPrecursor = reportsPlusPrecursor
}
